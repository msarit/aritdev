I"ˆ<p>As part of my current project â€” building an Instagram-like app called â€œGrammableâ€ â€” Iâ€™m being introduced to the efficient world of Test-Driven Development. Weâ€™re using the RSpec gem to run tests on our Rails apps. I like it, I like it a lot. I appreciate being able to test my appâ€™s functionality without reloading my browser a million times (no exaggeration).</p>

<p>{% include tweet-card.html quote=â€Test-Driven Development helps us understand why code is there, what it does, and what happens without itâ€ %}</p>

<p>Some aspects of the test-writing process have stumped me though. For example, hereâ€™s my code testing whether a user who didnâ€™t create a post (known as a â€˜gramâ€™) is prevented from editing it:</p>

<p>{% highlight ruby %}
  it â€œshouldnâ€™t let a user who did not create the gram edit a gramâ€ do
    gram = FactoryBot.create(:gram)
    user = FactoryBot.create(:user)
    sign_in user
    get :edit, params: { id: gram.id }
    expect(response).to have_http_status(:forbidden)
  end
{% endhighlight %}</p>

<p>I use the FactoryBot gem to DRY my code up, instead of repeatedly including the code block to create a gram and/or user. Now, the way I understood the code above was: since the gramâ€™s creator is signing in, why is the test passing, i.e. not allowing â€˜userâ€™ to edit the gram? Turns out, there are TWO users created within this test. The â€˜factoryâ€™ that dictates gram creation associates each gram with a user (its â€˜creatorâ€™):</p>

<p>{% highlight ruby %}
  factory :gram do
    message â€œHello!â€
    picture { fixture_file_upload(Rails.root.join(â€˜specâ€™, â€˜fixturesâ€™, â€˜picture.pngâ€™).to_s, â€˜image/pngâ€™) }
    association :user
  end
{% endhighlight %}</p>

<p>However, the â€˜userâ€™ defined in my test is completely different, and isnâ€™t associated with the gram that was created. The nuance seems obvious, but imagine having to practice this discernment while working with a codebase thousands of lines long. It makes more sense to choose a variable name (â€˜diff_userâ€™ in this case) that clues the coder in:</p>

<p>{% highlight ruby %}
  it â€œshouldnâ€™t let a user who did not create the gram edit a gramâ€ do
    gram = FactoryBot.create(:gram)
    diff_user = FactoryBot.create(:user)
    sign_in diff_user
    get :edit, params: { id: gram.id }
    expect(response).to have_http_status(:forbidden)
  end
{% endhighlight %}</p>

<p>Another sticking point I encountered had to do with my â€œdestroyâ€ action, namely ensuring that the browser returned a 404 error when attempting to delete a non-existent gram:</p>

<p>{% highlight ruby %}
  it â€œshould return a 404 error if gram with the specified id cannot be foundâ€ do
    delete :destroy, params: { id: â€˜SPACEDUCKâ€™ }
    expect(response).to have_http_status(:not_found)
  end
{% endhighlight %}</p>

<p>My initial reasoning was: â€œSince we are dealing with a non-existent gram, whatâ€™s the point of signing a user in?â€ I was thinking along the lines of â€œa gram belongs to a user; no gram, so no userâ€. So I commented out the â€˜userâ€™ creation-and-sign-in code and ran my tests again. ï¸Instead of a 404 Not-Found error, I got a 302 Found<br />
Redirect response. Redirect? But why? And WHERE? Well, my app was redirecting to the Sign-In page, which was behavior I had configured in my gram controller:</p>

<p>{% highlight ruby %}
  it â€œshouldnâ€™t let unauthenticated users destroy a gramâ€ do
    gram = FactoryBot.create(:gram)
    delete :destroy, params: { id: gram.id }
    expect(response).to redirect_to new_user_session_path
  end
{% endhighlight %}</p>

<p>My gram controller requires users to sign-in before accessing any actions defined therein (including the â€œdestroyâ€ action), and my test was simply confirming this. So I re-added the user creation and sign-in code and all tests passed successfully.</p>

<hr />

<p>I remember sharing with my mentor early-on in my learning: â€œJeremy, itâ€™s frightfully tempting to merely reproduce the code being taught to me, without properly grasping why itâ€™s there, what itâ€™s doing, and what happens without it.â€ The hangups I describe above may seem quite juvenile, but what I value is the approach by which I came across them:  <strong>questioning everything</strong>  (well,  <strong><em>almost</em></strong>  everything). I aim to become an expert programmer through actually understanding what Iâ€™m learning, not memorizing or winging it.</p>
:ET