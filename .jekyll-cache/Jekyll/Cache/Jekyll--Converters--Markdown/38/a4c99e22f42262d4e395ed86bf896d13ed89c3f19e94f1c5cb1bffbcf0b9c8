I"/!<p>As part of my current project — building an Instagram-like app called “Grammable” — I’m being introduced to the efficient world of Test-Driven Development. We’re using the RSpec gem to run tests on our Rails apps. I like it, I like it a lot. I appreciate being able to test my app’s functionality without reloading my browser a million times (no exaggeration).</p>

<div class="tweet-card tweet-card-shadow">
  <div class="blogQuote">
    "Test-Driven Development helps us understand why code is there, what it does, and what happens without it"
  </div>
</div>

<p>Some aspects of the test-writing process have stumped me though. For example, here’s my code testing whether a user who didn’t create a post (known as a ‘gram’) is prevented from editing it:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">it</span> <span class="s2">"shouldn't let a user who did not create the gram edit a gram"</span> <span class="k">do</span>
    <span class="n">gram</span> <span class="o">=</span> <span class="no">FactoryBot</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:gram</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">FactoryBot</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
    <span class="n">sign_in</span> <span class="n">user</span>
    <span class="n">get</span> <span class="ss">:edit</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">id: </span><span class="n">gram</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">response</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_http_status</span><span class="p">(</span><span class="ss">:forbidden</span><span class="p">)</span>
  <span class="k">end</span></code></pre></figure>

<p>I use the FactoryBot gem to DRY my code up, instead of repeatedly including the code block to create a gram and/or user. Now, the way I understood the code above was: since the gram’s creator is signing in, why is the test passing, i.e. not allowing ‘user’ to edit the gram? Turns out, there are TWO users created within this test. The ‘factory’ that dictates gram creation associates each gram with a user (its ‘creator’):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">factory</span> <span class="ss">:gram</span> <span class="k">do</span>
    <span class="n">message</span> <span class="s2">"Hello!"</span>
    <span class="n">picture</span> <span class="p">{</span> <span class="n">fixture_file_upload</span><span class="p">(</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'spec'</span><span class="p">,</span> <span class="s1">'fixtures'</span><span class="p">,</span> <span class="s1">'picture.png'</span><span class="p">).</span><span class="nf">to_s</span><span class="p">,</span> <span class="s1">'image/png'</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">association</span> <span class="ss">:user</span>
  <span class="k">end</span></code></pre></figure>

<p>However, the ‘user’ defined in my test is completely different, and isn’t associated with the gram that was created. The nuance seems obvious, but imagine having to practice this discernment while working with a codebase thousands of lines long. It makes more sense to choose a variable name (‘diff_user’ in this case) that clues the coder in:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">it</span> <span class="s2">"shouldn't let a user who did not create the gram edit a gram"</span> <span class="k">do</span>
    <span class="n">gram</span> <span class="o">=</span> <span class="no">FactoryBot</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:gram</span><span class="p">)</span>
    <span class="n">diff_user</span> <span class="o">=</span> <span class="no">FactoryBot</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
    <span class="n">sign_in</span> <span class="n">diff_user</span>
    <span class="n">get</span> <span class="ss">:edit</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">id: </span><span class="n">gram</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">response</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_http_status</span><span class="p">(</span><span class="ss">:forbidden</span><span class="p">)</span>
  <span class="k">end</span></code></pre></figure>

<p>Another sticking point I encountered had to do with my “destroy” action, namely ensuring that the browser returned a 404 error when attempting to delete a non-existent gram:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">it</span> <span class="s2">"should return a 404 error if gram with the specified id cannot be found"</span> <span class="k">do</span>
    <span class="n">delete</span> <span class="ss">:destroy</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">id: </span><span class="s1">'SPACEDUCK'</span> <span class="p">}</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">response</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_http_status</span><span class="p">(</span><span class="ss">:not_found</span><span class="p">)</span>
  <span class="k">end</span></code></pre></figure>

<p>My initial reasoning was: “Since we are dealing with a non-existent gram, what’s the point of signing a user in?” I was thinking along the lines of “a gram belongs to a user; no gram, so no user”. So I commented out the ‘user’ creation-and-sign-in code and ran my tests again. ️Instead of a 404 Not-Found error, I got a 302 Found<br />
Redirect response. Redirect? But why? And WHERE? Well, my app was redirecting to the Sign-In page, which was behavior I had configured in my gram controller:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">it</span> <span class="s2">"shouldn't let unauthenticated users destroy a gram"</span> <span class="k">do</span>
    <span class="n">gram</span> <span class="o">=</span> <span class="no">FactoryBot</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:gram</span><span class="p">)</span>
    <span class="n">delete</span> <span class="ss">:destroy</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">id: </span><span class="n">gram</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">response</span><span class="p">).</span><span class="nf">to</span> <span class="n">redirect_to</span> <span class="n">new_user_session_path</span>
  <span class="k">end</span></code></pre></figure>

<p>My gram controller requires users to sign-in before accessing any actions defined therein (including the “destroy” action), and my test was simply confirming this. So I re-added the user creation and sign-in code and all tests passed successfully.</p>

<hr />

<p>I remember sharing with my mentor early-on in my learning: “Jeremy, it’s frightfully tempting to merely reproduce the code being taught to me, without properly grasping why it’s there, what it’s doing, and what happens without it.” The hangups I describe above may seem quite juvenile, but what I value is the approach by which I came across them:  <strong>questioning everything</strong>  (well,  <strong><em>almost</em></strong>  everything). I aim to become an expert programmer through actually understanding what I’m learning, not memorizing or winging it.</p>
:ET